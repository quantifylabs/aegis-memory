---
title: "Architecture RFC v1"
description: "Proposed architecture boundaries and migration plan for Aegis Memory."
---

# Architecture RFC v1

## 1) Goals

This RFC proposes a practical, low-risk path to evolve Aegis Memory toward:

- Strong multi-tenant isolation and auth boundaries.
- Deterministic schema lifecycle with migration safety.
- Better retrieval/access-control scalability.
- Clearer module boundaries for maintainability.
- Reproducible release and benchmark discipline.

## 2) Non-goals

- Rewriting the core retrieval logic from scratch.
- Switching away from PostgreSQL/pgvector.
- Introducing distributed infrastructure that is not required for single-node self-hosted deployments.

## 3) Proposed bounded contexts

Split server responsibilities into explicit domains.

```text
server/
  api/
    app.py
    dependencies/
      auth.py
      rate_limit.py
    routers/
      memories.py
      handoffs.py
      ace_votes.py
      ace_progress.py
      ace_reflections.py
      dashboard.py
  domain/
    memory/
      models.py
      service.py
      repository.py
      policy.py
    ace/
      models.py
      service.py
      repository.py
    events/
      models.py
      service.py
  infra/
    db/
      engine.py
      session.py
      migrations/
    embeddings/
      service.py
      providers/
        openai.py
    observability/
      metrics.py
      event_pipeline.py
    auth/
      token_verifier.py
      key_store.py
```

### Boundary rules

- Routers perform validation and HTTP mapping only.
- Domain services own business rules (scope inference, ACL checks, ACE policy).
- Repositories own persistence/query shape only.
- Infra modules are replaceable adapters (embedding provider, auth backend, exporter backend).

## 4) Security and tenancy target state

### Current risk

A single server key mapped to a single `default_project_id` can blur tenant boundaries.

### Proposed target

- **Project-scoped credentials** (at minimum): API key or signed token per project.
- **Agent-scoped claims** (recommended): optional claim set for `agent_id` + permitted namespaces/scopes.
- **Authorization policy object** in domain layer:
  - `can_write_memory(principal, target_project, scope, agent_id)`
  - `can_query_memory(principal, target_project, requested_scope, target_agents)`

### Minimal rollout

1. Add `projects` + `api_keys` table and verification adapter.
2. Return `project_id` from auth dependency based on credential lookup.
3. Keep header contract unchanged (`Authorization: Bearer ...`) for compatibility.
4. Add opt-in JWT mode later.

## 5) Data model and ACL evolution

### Current pressure point

ACL checks over JSON arrays (`shared_with_agents`) are convenient but less index-friendly over time.

### Proposed schema addition

Introduce normalized sharing edges:

- `memory_shared_agents(memory_id, project_id, namespace, shared_agent_id, created_at)`
- Unique index: `(memory_id, shared_agent_id)`
- Query index: `(project_id, namespace, shared_agent_id)`

### Compatibility strategy

- Keep `shared_with_agents` column during transition.
- Dual-write from service layer for one release.
- Move read path to join table.
- Remove JSON-based ACL checks after confidence window.

## 6) Schema lifecycle strategy

Adopt Alembic as canonical schema source.

### Rules

- No `metadata.create_all()` in production startup.
- Every schema change requires:
  1. Alembic migration.
  2. Upgrade/downgrade test in CI.
  3. Release note entry.

### Rollout steps

1. Generate baseline migration from current schema.
2. Add migration command wrapper (`make db-migrate`, `make db-upgrade`).
3. Gate server startup on schema version check.

## 7) Transaction boundaries and consistency

### Principle

Only one layer controls commit/rollback for a request lifecycle.

### Proposed implementation

- Route dependency opens session.
- Service/repository functions do not call `commit()`.
- Route dependency commits on success, rollbacks on exception.

### Benefit

Predictable behavior across embedding-cache writes, memory writes, and event emission.

## 8) Rate limiting architecture

Unify runtime backend selection:

- `RATE_LIMIT_BACKEND=memory|redis`
- `RateLimiterProtocol` with common interface.
- Inject backend via dependency wiring.

### Semantics

- Enforce minute, hour, and burst policies explicitly.
- Expose limit headers (`X-RateLimit-*`) for client visibility.

## 9) Observability and SLOs

Define baseline service objectives:

- `p95 /memories/query < 150ms` (without external embedding call).
- `error_rate < 1%` per 5-minute window.
- Event exporter drop rate `= 0` under nominal load.

Add required telemetry dimensions:

- `project_id`, `namespace`, `scope`, `operation`, `status`, `latency_bucket`.
- Queue depth metrics for event pipeline and embedding cache hit ratio.

## 10) Release and benchmarking discipline

### Version consistency

- Single source of truth for version at build-time.
- Inject version into API responses/docs from package metadata.

### Benchmark reproducibility

Publish scripts and artifacts for README claims:

- Dataset generator + seed.
- Query workload config.
- Raw run outputs + percentile summary.
- Machine profile capture.

## 11) Migration plan (90 days)

### Phase 1 (Weeks 1-2): Security foundations

- Add project-key tables and auth dependency adapter.
- Keep backward-compatible fallback behind feature flag.
- Add audit logging for auth decisions.

### Phase 2 (Weeks 3-4): Schema governance

- Alembic baseline; disable runtime schema auto-create in prod mode.
- CI migration checks (upgrade + downgrade).

### Phase 3 (Weeks 5-7): ACL scalability

- Introduce `memory_shared_agents` table.
- Dual-write + read switch + backfill migration.

### Phase 4 (Weeks 8-10): Module decomposition

- Split large routers/repositories by bounded context.
- Introduce service layer contracts.

### Phase 5 (Weeks 11-12): Operational hardening

- Unified rate-limiter backend wiring.
- Version synchronization automation.
- Benchmark artifact publication.

## 12) Acceptance criteria

- Per-project auth enforced and validated by tests.
- No production startup path mutates schema.
- ACL query plans use indexed joins for shared-access lookups.
- Route modules each remain under ~300 lines target.
- README performance claims link to committed reproducible artifacts.

## 13) Open questions

- Should project-level keys support namespace scoping from day one?
- Do we need row-level encryption for selected memory categories?
- Is event pipeline durability needed (disk/queue) for strict no-loss mode?

## 14) Appendix: suggested first issues

1. `feat(auth): project-scoped API key store + verifier`
2. `chore(db): alembic baseline and startup schema guard`
3. `feat(acl): add memory_shared_agents + dual-write`
4. `refactor(api): split routes.py into memories/handoffs routers`
5. `chore(release): unify API/package version reporting`
6. `chore(bench): add reproducible benchmark harness and artifacts`
